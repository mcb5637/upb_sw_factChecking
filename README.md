# Fact Checking

## Approach

Our approach is based on https://aclanthology.org/2020.coling-main.147.pdf (we found no code belonging to the paper)
and uses Jenas custom rule inferring capability https://jena.apache.org/documentation/inference/#rules for rule evaluating.
Rule Generation uses Jenas SPARQL evaulation https://jena.apache.org/documentation/query/index.html .

### Rule generation

Rule generation is based on the provided example triples and works in 4 steps:

- create a local graph of all paths consisting of less than a configured triple count, connecting the subject and object of each example triple.
- in this local graph generate example paths connecting subject and object.
- from each of these paths, a rule is generated.
- matching to each rule, an unbound rule is generated by replacing all connected variables by separate ones.

Examples that have a truth value of 1 lead to positive rules (that support the veracity of the triple to be checked)
and examples that have a truth value of 0 lead to negative rules (that oppose the veracity of the triple to be checked).

Note that we skipped adding the additional predicates to the local graph mentioned in the referenced paper.

### Rule evaluation

To check, if a rule applies to a triple, we check if applying the rule to our knowledge base results in the triple to be checked.
This step is used as part of both following steps.

### Rule weighting

The weight of a rule represents how strong it is (i.e. how many of the correct examples it covers and how many of the incorrect examples it not covers).
Calculating the weight is done the same way as in the paper, based on the number of examples it covers and the number of examples it could cover
(from the previously mentioned unbounded rules), split between true and false examples.

As an addition to the formula presented in the paper, we cap each rules strength at 1.

### Fact checking

To check a triple, we calculate a veracity value for it, the same way as presented in the paper.
To do this, first we check all positive and negative rules and use the highest weight of any applying rule in both categories for further calculations.
From these positive and negative weights we calculate a final veracity value with the same formula as presented in the paper.

## Build requirements

Installed java and gradle. Other requirements are managed by gradle.

## Build Instructions

To build a single jar file with all dependencies, run the following command:

```shell
$ ./gradlew shadowJar
```

The jar file will be located at `app/build/libs/upb_sw_factChecking.jar`.

## Run Instructions

To run the compiled jar file, execute the following command:

```shell
java -jar upb_sw_factChecking.jar
```

## Usage

The application has two commands `check` and `evaluate`.
The `check` command checks the correctness of rdf statements in the given test file.
The `evaluate` command evaluates the systems performance against a training set.
Rules are generated automatically when started the first time and then saved to a file.
Subsequent executions will load and use these previously stored rules.

```shell
java -jar upb_sw_factChecking.jar check    ( fokgsw | --test-file FILE ) --dump-file FILE [ --output-file FILE ]
java -jar upb_sw_factChecking.jar evaluate ( fokgsw | --test-file FILE ) --dump-file FILE [ --output-file FILE ]
```